<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.433">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Rui-Yang Zhang">
<meta name="dcterms.date" content="2025-10-09">
<meta name="description" content="The Matheron rule of conditional multivariate normal distribution offers a new way to approximately sample from a posterior Gaussian process.">

<title>Rui-Yang Zhang - Approximate GP Posterior Sampling via the Matheron Rule</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../rui.svg" rel="icon" type="image/svg+xml">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a href="../../index.html" class="navbar-brand navbar-brand-logo">
    <img src="../../rui.svg" alt="" class="navbar-logo">
    </a>
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Rui-Yang Zhang</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../index.html" rel="" target="">
 <span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../research.html" rel="" target="">
 <span class="menu-text">Research</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../notes.html" rel="" target="">
 <span class="menu-text">Notes &amp; Slides</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../resources.html" rel="" target="">
 <span class="menu-text">Resources</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../blog.html" rel="" target="">
 <span class="menu-text">Blog</span></a>
  </li>  
</ul>
            <div class="quarto-navbar-tools ms-auto">
</div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Approximate GP Posterior Sampling via the Matheron Rule</h1>
                  <div>
        <div class="description">
          The Matheron rule of conditional multivariate normal distribution offers a new way to approximately sample from a posterior Gaussian process.
        </div>
      </div>
                          <div class="quarto-categories">
                <div class="quarto-category">Gaussian Process</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Rui-Yang Zhang </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">October 9, 2025</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#matheron-rule" id="toc-matheron-rule" class="nav-link active" data-scroll-target="#matheron-rule">Matheron Rule</a></li>
  <li><a href="#approximate-sampling" id="toc-approximate-sampling" class="nav-link" data-scroll-target="#approximate-sampling">Approximate Sampling</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">




<p><em>This blog post is about <span class="citation" data-cites="wilson2020efficiently">J. Wilson et al. (<a href="#ref-wilson2020efficiently" role="doc-biblioref">2020</a>)</span> and <span class="citation" data-cites="wilson2021pathwise">J. T. Wilson et al. (<a href="#ref-wilson2021pathwise" role="doc-biblioref">2021</a>)</span>.</em></p>
<section id="matheron-rule" class="level2">
<h2 class="anchored" data-anchor-id="matheron-rule">Matheron Rule</h2>
<p>The Matheron rule states that, for random variables <span class="math inline">\(a\)</span>, <span class="math inline">\(b\)</span> that are jointly Gaussian, the conditional distribution <span class="math inline">\(a | b = \beta\)</span> is given by</p>
<p><span class="math display">\[
(a| b = \beta) \stackrel{d}{=} a + \Sigma_{a,b} \Sigma_{b,b}^{-1} (\beta - b)
\]</span></p>
<p>where <span class="math inline">\(\stackrel{d}{=}\)</span> means distributional equivalence, <span class="math inline">\(\Sigma_{a,b} := \text{Cov}(a, b)\)</span> and <span class="math inline">\(\Sigma_{b,b} := \text{Cov}(b, b)\)</span>. This can be verified easily by matching the mean and covariance of the two sides of the equation.</p>
<p>Using this formulation of conditional Gaussian, we can extrapolate it to a Gaussian process (GP) and obtain the following result. For a GP <span class="math inline">\(f \sim GP(\mu, k)\)</span> with marginal <span class="math inline">\(f_n = f(X_n)\)</span> at observation locations <span class="math inline">\(X_n\)</span> that gives noisy observations <span class="math inline">\(y = f(X_n) + \varepsilon\)</span> for <span class="math inline">\(\varepsilon \sim N(0, \sigma^2 I_n)\)</span>, we have the Matheron rule for posterior GP <span class="math inline">\(f|y\)</span></p>
<p><span class="math display">\[
(f|y) (\cdot) \stackrel{d}{=} f(\cdot) + k(\cdot, X_n) (K_{n, n} + \sigma^2I_n)^{-1} (y - f_n - \varepsilon)
\]</span></p>
<p>where <span class="math inline">\(K_{n,n} = k(X_n, X_n)\)</span> is the Gram matrix of <span class="math inline">\(X_n\)</span> with GP kernel <span class="math inline">\(k\)</span>.</p>
<p>At this point, we recall that the standard formulation posterior GP at test points <span class="math inline">\(X_* \in \mathbb{R}^m\)</span> is given by</p>
<p><span class="math display">\[
\begin{split}
f(X_*) |y &amp;\sim N_{n}(\mu_{* | y}, K_{* | y}), \\
\mu_{* | y} &amp;= \mu(X) + K_{*,n}^T (K_{n,n} + \sigma^2 I_n)^{-1} y,\\
K_{* | y} &amp;= K_{*,*} - K_{*,n} (K_{n,n} + \sigma^2 I_n)^{-1}K_{*,n}^T.
\end{split}
\]</span></p>
<p>and to draw a sample <span class="math inline">\(f_*^{(1)}\)</span> from such a posterior <span class="math inline">\(f(X_*) |y\)</span>, we have</p>
<p><span class="math display">\[
f_*^{(1)} = \mu_{* | y} + \sqrt{K_{* | y}} ~\xi, \qquad \xi \sim N(0, I)
\]</span></p>
<p>where the matrix ‘square root’ <span class="math inline">\(\sqrt{A} := L\)</span> where <span class="math inline">\(LL^T = A\)</span>. Such matrix square roots are usually obtained using <a href="https://en.wikipedia.org/wiki/Cholesky_decomposition">Cholesky decomposition</a>, which has <span class="math inline">\(O(m^3)\)</span> time complexity for <span class="math inline">\(A \in \mathbb{R}^{m \times m}\)</span>. Thus, assuming the posterior mean and covariance are already obtained, the cost of drawing a posterior sample is <span class="math inline">\(O(m^3)\)</span> for <span class="math inline">\(m\)</span> test points.</p>
<p>Now, to samples directly using the Matheron rule formulation, we have</p>
<p><span class="math display">\[
(f|y) (X_*) \stackrel{d}{=} f(X_*) + k(X_*, X_n) (K_{n, n} + \sigma^2I_n)^{-1} (y - f(X_n) - \varepsilon)
\]</span></p>
<p>and thus after obtaining a sample <span class="math inline">\(f^{(1),prior} = f_*^{(1),prior} \cup f_n^{(1),prior}\)</span> from the prior <span class="math inline">\(f(X)\)</span> with <span class="math inline">\(X = X_* \cup X_n\)</span>, we can obtain a posterior sample <span class="math inline">\(f_*^{(1)}\)</span> as</p>
<p><span class="math display">\[
f_*^{(1)} = f_*^{(1),prior} + k(X_*, X_n) (K_{n, n} + \sigma^2I_n)^{-1} (y - f_n^{(1),prior} - \varepsilon^{(1)}), \quad \varepsilon^{(1)} \sim N(0, \sigma^2 I_n)
\]</span></p>
<p>which cost <span class="math inline">\(O((m+n)^3)\)</span> assuming all the mean and covariance are pre-computed as its takes <span class="math inline">\(O((m+n)^3)\)</span> to compute the matrix square root <span class="math inline">\(k(X, X)\)</span> to sample <span class="math inline">\(f^{(1),prior}\)</span>, although the cost could be reduced to <span class="math inline">\(O(m^3+n^3)\)</span> using <a href="https://en.wikipedia.org/wiki/Schur_complement">Schur complement</a>. Thus, as it stands currently, there is <em>no computational benefit</em> of posterior sampling using the Matheron rule – even a loss when <span class="math inline">\(X_n \not \subset X_*\)</span>! However, when we start to draw samples approximately, the Materon rule offers more flexibility.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="illustration.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption"><span class="citation" data-cites="wilson2021pathwise">J. T. Wilson et al. (<a href="#ref-wilson2021pathwise" role="doc-biblioref">2021</a>)</span></figcaption>
</figure>
</div>
</section>
<section id="approximate-sampling" class="level2">
<h2 class="anchored" data-anchor-id="approximate-sampling">Approximate Sampling</h2>
<p>Recall the general Matheron rule for GP posterior yields</p>
<p><span class="math display">\[
(f|y) (\cdot) \stackrel{d}{=} \underbrace{f(\cdot)}_\text{prior} + \underbrace{k(\cdot, X_n) (K_{n, n} + \sigma^2I_n)^{-1} (y - f_n - \varepsilon)}_\text{update}
\]</span> where the first term on the right is a <em>prior</em> term, and the second term is the <em>update</em> term. The two computational bottlenecks for posterior sampling in this fashion are (a) the sampling from prior, and (b) the computation of matrix inverse and multiple for the update. When we turn to approximate sampling, the decoupling of terms due to the Matheron rule enables us to use different approximations to each of the prior and update terms, as opposed to applying one approximation throughout in standard posterior sampling.</p>
<p>Many approximation methods for GP exist:</p>
<ul>
<li>[Low Rank] Random Fourier feature <span class="citation" data-cites="rahimi2007random">(<a href="#ref-rahimi2007random" role="doc-biblioref">Rahimi and Recht 2007</a>)</span></li>
<li>[Sparse] Inducing points <span class="citation" data-cites="titsias2009variational leibfried2020tutorial">(<a href="#ref-titsias2009variational" role="doc-biblioref">Titsias 2009</a>; <a href="#ref-leibfried2020tutorial" role="doc-biblioref">Leibfried et al. 2020</a>)</span></li>
<li>[Iterative] Conjugate gradient <span class="citation" data-cites="pleiss2020scalable">(<a href="#ref-pleiss2020scalable" role="doc-biblioref">Pleiss 2020</a>)</span>, SGD <span class="citation" data-cites="lin2023sampling">(<a href="#ref-lin2023sampling" role="doc-biblioref">Lin et al. 2023</a>)</span></li>
</ul>
<p>All of the above can be mixed-and-matched to approximate the prior and update terms of the Matheron update to utilise their respective pros. For example, the results in <span class="citation" data-cites="wilson2021pathwise">J. T. Wilson et al. (<a href="#ref-wilson2021pathwise" role="doc-biblioref">2021</a>)</span> suggest that random Fourier feature is good for approximating the prior term, while conjugate gradient is suitable for approximating the update.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="example.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption"><span class="citation" data-cites="wilson2021pathwise">J. T. Wilson et al. (<a href="#ref-wilson2021pathwise" role="doc-biblioref">2021</a>)</span></figcaption>
</figure>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="result.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption"><span class="citation" data-cites="wilson2021pathwise">J. T. Wilson et al. (<a href="#ref-wilson2021pathwise" role="doc-biblioref">2021</a>)</span></figcaption>
</figure>
</div>



</section>

<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" role="doc-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" role="list">
<div id="ref-leibfried2020tutorial" class="csl-entry" role="listitem">
Leibfried, Felix, Vincent Dutordoir, ST John, and Nicolas Durrande. 2020. <span>“A Tutorial on Sparse Gaussian Processes and Variational Inference.”</span> <em>arXiv Preprint arXiv:2012.13962</em>.
</div>
<div id="ref-lin2023sampling" class="csl-entry" role="listitem">
Lin, Jihao Andreas, Javier Antorán, Shreyas Padhy, David Janz, José Miguel Hernández-Lobato, and Alexander Terenin. 2023. <span>“Sampling from Gaussian Process Posteriors Using Stochastic Gradient Descent.”</span> <em>Advances in Neural Information Processing Systems</em> 36: 36886–912.
</div>
<div id="ref-pleiss2020scalable" class="csl-entry" role="listitem">
Pleiss, Geoff. 2020. <em>A Scalable and Flexible Framework for Gaussian Processes via Matrix-Vector Multiplication</em>. Cornell University.
</div>
<div id="ref-rahimi2007random" class="csl-entry" role="listitem">
Rahimi, Ali, and Benjamin Recht. 2007. <span>“Random Features for Large-Scale Kernel Machines.”</span> <em>Advances in Neural Information Processing Systems</em> 20.
</div>
<div id="ref-titsias2009variational" class="csl-entry" role="listitem">
Titsias, Michalis. 2009. <span>“Variational Learning of Inducing Variables in Sparse Gaussian Processes.”</span> In <em>Artificial Intelligence and Statistics</em>, 567–74. PMLR.
</div>
<div id="ref-wilson2021pathwise" class="csl-entry" role="listitem">
Wilson, James T, Viacheslav Borovitskiy, Alexander Terenin, Peter Mostowsky, and Marc Peter Deisenroth. 2021. <span>“Pathwise Conditioning of Gaussian Processes.”</span> <em>Journal of Machine Learning Research</em> 22 (105): 1–47.
</div>
<div id="ref-wilson2020efficiently" class="csl-entry" role="listitem">
Wilson, James, Viacheslav Borovitskiy, Alexander Terenin, Peter Mostowsky, and Marc Deisenroth. 2020. <span>“Efficiently Sampling Functions from Gaussian Process Posteriors.”</span> In <em>International Conference on Machine Learning</em>, 10292–302. PMLR.
</div>
</div></section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>